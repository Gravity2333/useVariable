import*as e from"react";import*as t from"react-dom";var r={d:(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},n={};r.d(n,{f:()=>o,A:()=>b});const c=(a={useMemo:()=>e.useMemo,useRef:()=>e.useRef,useState:()=>e.useState},u={},r.d(u,a),u),o="/";var a,u;const s=(e=>{var t={};return r.d(t,e),t})({flushSync:()=>t.flushSync});function f(e,t,r,n){for(const c in e){const o=e[c];"object"==typeof o&&null!==o&&(e[c]=f(o,t,r,n))}return new Proxy(e,{get(e,t,n){const c=Reflect.get(e,t,n);return r&&r(e,t,n),c},set(e,r,n,c){const o=Reflect.set(e,r,n,c);return t&&t(e,r,n,c),o},deleteProperty(e,t){const r=Reflect.deleteProperty(e,t);return n&&n(e,t),r}})}function l({config:e=[]}){const[t]=function(){const[e,t]=(0,c.useState)(0);return[()=>{(0,s.flushSync)((()=>{t(e>99999?0:e=>e+1)}))}]}(),r=(0,c.useRef)(f(e.reduce(((e,t)=>({...e,[t.name]:void 0!==t.initialValue?t.initialValue:{}})),{}),t,(()=>{}),t)),[n,a]=(0,c.useState)({});function u(e,t=!1){void 0!==n[e]&&a((r=>({...r,[e]:t})))}const l=(0,c.useMemo)((()=>{const t={},r=e.reduce(((e,r)=>(0!==Object.keys(r.effects||{})?.length&&Object.keys(r.effects||{}).forEach((e=>{t[`${r.name}${o}${e}`]=!1})),{...e,[r.name]:r})),{})||{};return a(t),r}),[]),i=(e,t,n,c)=>{const o=r.current[t];!function(){const t=[];let r=0;const a=(e,n)=>{const c=t[r];if(!c){const c={};throw t[r++]=c,e(n).then((e=>{c.status="fulfilled",c.value=e}),(e=>{c.status="rejected",c.error=e}))}if(r++,"fulfilled"===c.status)return c.value;if("rejected"===c.status)throw new Error(c.error)},s=()=>{try{(t=>{e({call:t,setLoading:u.bind(null,n)},{store:o,dispatch:d},c)})(a)}catch(e){return e instanceof Promise&&e.then((()=>{r=0,s()})),{}}};s()}()},d=({type:e,payload:t})=>{const[n,c]=e.split(o),a=l[n],{reducers:u={},effects:s={}}=a;s[c]?i(s[c],n,e,t):u[c]&&((e,t,n)=>{e(r.current[t],{payload:n})})(u[c],n,t)};return[r.current,d,function(e){return n[e]}]}const i="VARIABLES";function d(e){return`${i}${o}${e}`}function y(e){const t={name:i,initialValue:{},reducers:{},effects:{}},{variables:r={},reducers:n={},effects:c={}}=e;return Object.keys(r).forEach((e=>{const n=r[e];Object.defineProperty(t.initialValue,e,{value:n,configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(t.reducers,function(e){return`set${t=e,t.charAt(0).toUpperCase()+t.slice(1)}`;var t}(e),{configurable:!0,enumerable:!0,writable:!0,value:(t,r)=>{t[e]=r.payload}})})),Object.keys(n).forEach((e=>{Object.defineProperty(t.reducers,e,{configurable:!0,enumerable:!0,writable:!0,value:n[e]})})),Object.keys(c).forEach((e=>{Object.defineProperty(t.effects,e,{configurable:!0,enumerable:!0,writable:!0,value:c[e]})})),t}function b(e){const[t,r,n]=l({config:[y(e)]});return[t[i],e=>{r({type:d(e.type),payload:e.payload})},e=>n(d(e))]}var p=n.f,m=n.A;export{p as USE_STORE_TYPE_SPLITER,m as default};